---
title: "NDK 와 JNI 기본"
date: 2025-12-08 14:47:24 +0900
categories: [Android, NDK]
tags: [Android, NDK, JNI, C++, Native Development Kit, Java Native Interface]
mermaid: true
---

## NDK 란
**N**ative **D**evelopment **K**it 의 약자로서, Android 앱 개발 시 Java/Kotlin 코드와 상호작용 할 수 있도록 C/C++ 라이브러리를 지원하는 툴킷이다.

주로 고성능 그래픽처리나 오디오 신호 처리 등 **JVM 보다 빠른 연산 속도가 필요한 작업**에 활용된다.

C/C++ 코드를 사용하여 무거운 연산의 성능 최적화뿐만 아니라 FFmpeg, OpenCV 등 레거시 C/C++ 라이브러리를 안드로이드 앱에 이식할때 필수적으로 사용된다.

## JNI 란
**J**ava **N**ative **I**nterface 의 약자로서, Java/Kotlin 코드와 NDK로 작성된 C/C++ 코드가 서로 통신할 수 있도록 연결해 주는 인터페이스 이다.

두 언어 환경 사이에 브릿지 역할을 하여, Java/Kotlin 에서 Native 함수를 호출하여 결과를 받거나, 반대로 Native 코드에서 Java 객체를 제어할 수 있게 해준다.

서로 다른 메모리 구조를 가진 두 언어를 연결하기 때문에, **데이터를 변환하고 전달하는 과정(마샬링)에서 오버헤드가 발생**한다. 따라서 너무 **빈번하게 JNI 를 호출하는 것은 오히려 성능을 저하**시킬 수 있다.

## 프로젝트 구조
전체 구조도

Android Studio 의 Project View 를 Project 로 전환했을떄 아래의 구조가 된다
```
app(Module)
    main
     ├─ cpp
     │   ├─ include(외부 라이브러리를 사용하는 경우 별도 생성)
     │   ├─ CMakeLists.txt
     │   └─ native-lib.cpp
     ├─ java
     │   └─ com
     │       └─ example
     │           └─ sample
     │               ├─ MainActivity
     │               └─ JniBridge.kt(별도 생성)
     └─ JniLibs(외부 라이브러리를 사용하는 경우 아키텍처 별 하위 폴더까지 별도 생성)
            ├─ arm64-v8a
            └─ armeabi-v7a
```

### 실행 원리
네이티브 코드가 포함된 프로젝트가 빌드될 때는 아래와 같은 순서를 거친다.
1. 전체 프로젝트 빌드는 `Gradle` 이 수행한다.
2. 빌드 중 `Gradle` 은 프로젝트 내에 네이티브 소스의 빌드가 필요함을 감지한다.
3. `CMake` 가 호출되고, `CMakeLists.txt` 를 읽고 분석한다.
4. 분석된 내용(소스코드 위치, 라이브러리 이름 등) 을 바탕으로 컴파일러(`Clang` 등) 에게 명령을 내려 실제 소스코드를 컴파일하고 링킹한다.
5. 그 결과로, 라이브러리 이름의 `.so` 파일이 생성된다.
6. Gradle 은 앞서 컴파일된 Java 바이너리(`.dex`) 와 Native 바이너리(`.so`) 를 합쳐 하나의 `.apk` 로 만든다.
7. 실제 앱이 실행될때, JNI 를 통해 네이티브 기능에 접근하는 시점에 `.so` 파일을 메모리에 올리고 특정 기능을 수행한다.

### 1. 새로운 프로젝트를 만들 경우(Android Studio )
1. File -> New Project  
2. Native C++ 선택
    ![프로젝트 생성 - 1](https://host.ggoggo.duckdns.org/Blog/251208_ndk/new_project_1.png)
3. 프로젝트명, 패키지명, 저장위치, 언어(Java/Kotlin), Minimum SDK, Build configuration language 는 기존 프로젝트 생성할때와 동일하게 작성한다.
    ![프로젝트 생성 - 2](https://host.ggoggo.duckdns.org/Blog/251208_ndk/new_project_2.png)
4. C++ 버전을 선택한다. 선택하지 않으면 **C++ 의 지원되는 기능은 NDK 버전에 따라 달라**진다.
    ![프로젝트 생성 - 3](https://host.ggoggo.duckdns.org/Blog/251208_ndk/new_project_3.png)
### 2. 기존 프로젝트에 NDK 를 통합하는 경우
1. Project View 를 Android 에서 Project 로 변경한다.
2. SDK Manager -> SDK Tools 에서 `NDK(Side by side)` 와 `CMake` 를 설치한다. 혹 버전을 선택하여 설치하고 싶다면, 하위의 `Show Package Details` 를 체크하여 원하는 버전을 선택하여 설치한다.
3. main 하위에 new -> Directory `cpp` 를 생성한다.
4. cpp 폴더 하위에 new -> CMakeLists.txt 를 추가한다.
5. cpp 폴더 하위에 new -> C/C++ Source File 을 추가한다. 해당 파일은 JNI 를 통해 통신할 기본적인 cpp 파일이다.
6. 3에서 추가한 `CMakeLists.txt` 에 아래 내용을 기입한다. 각 부분별 설명은 아래에서 자세히 다룬다.
    ```cmake
    # 개발환경에 설치된 CMake 버전을 명시한다.
    cmake_minimum_required(VERSION 3.22.1) 

    # 프로젝트 명을 기재
    project("myapplication")

    # 생성할 라이브러리의 이름. 예를 들어 ndk-test 로 지정하면 빌드 시 libnek-test.so 파일이 빌드된다.
    add_library(library-name SHARED
        # 생성할 라이브러리에 포함될 cpp 파일을 기재한다. 기본적으로 5 에서 추가한 cpp 를 넣어주어야 한다.
        native-lib.cpp)
    
    # 실행파일이 의존하는 다른 라이브러리를 연결한다. 기본적으로 `android` 는 Native 레벨에서 Android OS 의 리소스에 접근하는데 사용되고, `log` 는 Native 코드 레벨에서 로그캣에 출력되는 로그를 사용하기 위함이다.
    target_link_libraries(library-name
        android
        log)
    ```
7. build.gradle(:app) 에서 아래 내용을 추가한다.
    ```kotlin
    externalNativeBuild {
        cmake {
            path = file("src/main/cpp/CMakeLists.txt") // CMakeLists.txt 파일이 위치한 경로
            version = "3.22.1" // CMake 버전
        }
    }
    ```
## CMakeLists.txt
`CMakeLists.txt` 파일은 네이티브 코드(C/C++) 를 빌드하는 빌드 시스템 `CMake` 를 위한 입력 파일이다. Android 프로젝트를 `gradle` 을 통해서 빌드할때 설정을 `build.gradle` 에 기재하는것과 동일한 역할을 한다.

아래에 작성되는 설정을 CMake 에 알려준다.
- C/C++ 컴파일러
- 소스파일
- 라이브러리 종속성
- 빌드 옵션
- 등등

### cmake_minimum_required(VERSION x.x.x)
CMake 를 실행하는데 필요한 최소 버전 정의
```cmake
cmake_minimum_required(VERSION 3.22.1)
```
### project("project_name")
프로젝트의 이름 정의. Android 프로젝트 이름과 달라도 상관없지만, 같게 맞추는게 좋음
```cmake
project("my_native_app")
```
### set(\<alias> \<path>)
특정 경로를 변수로 지정하는데 주로 사용된다.

외부 라이브러리(ffmpeg, onnxruntime 등) 의 .so 나 .a 를 프로젝트 내에서 사용할 경우, 헤더파일이 필요한데, 이 헤더파일의 경로를 지정한다.
```cmake
set(ONNXRUNTIME_HEADER_DIR ${CMAKE_CURRENT_LIST_DIR}/include/onnxruntime)
```

- `${CMAKE_CURRENT_LIST_DIR}` : 현재 처리중인 CMakeLists.txt 파일이 위치한 경로이다. 해당 파일을 기준으로 상대 경로를 구성할때 주로 사용한다.

> Android NDK 환경에서는 Gradle 이 CMake 를 실행하면서 여러 Android 관련 변수를 자동으로 전달한다,  
> - `${CMAKE_ANDROID_ARCH_ABI}` : 현재 빌드중인 ABI (예 : `armeabi-v7a`, `arm64-v8a`, `x86_64`)  
> - `${CMAKE_ANDROID_ARCH}` : ABI 를 더 추상화한 CPU 아키텍처 이름(예 : `arm64`, `arm`, `x86`, `x86_64`)
> - `${CMAKE_ANDROID_API}` : Android API Level (예 : `android-24`)  
> - `${CMAKE_ANDROID_NDK}` : 사용중인 NDK 경로
{: .prompt-tip }

### set(CMAKE_CXX_STANDARD \<version>)
사용할 C++ 표준 버전을 지정한다.
```cmake
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
```
- NDK 프로젝트에서는 명시적으로 지정하는것이 권장된다
- 지정하지 않으면 툴체인의 기본값을 사용하게 된다.

### add_library(\<name> \<type> [source files] ... )
_(내 JNI 브릿지가 포함된 메인 so 를 만들때 사용한다)_

소스파일을 컴파일하여 라이브러리를 생성한다.
- **name** : 생성할 라이브러리의 이름. 추후 Jni Kotlin 코드에서 `System.loadLibrary` 로 로드하는 이름.  
최종 출력 파일의 이름 앞에 `lib` 가 붙는다.
- **type** : 라이브러리 유형 지정
  - **SHARED** : 동적 링크 라이브러리(.so). NDK 에서 주로 사용한다.
  - **STATIC** : 정적 링크 라이브러리(.a). 다른 라이브러리에 링크되어 최종 so 에 포함된다.  
  반드시 어딘가에 링크되어야 한다. .so 처럼 독립적으로 로드가 불가능하다.
  - **OBJECT** : 목적파일(.o) 만 생성한다.  
  특수한 상황에서만 사용한다.
- **source files** : 빌드할 소스파일 목록이다. 빌드할 모든 cpp 파일을 여기에 전부 명시해야 한다.

STATIC 라이브러리를 SHARED 라이브러리에 링크할 경우, Position Independent Code 옵션이 필요하다.
```cmake
set_target_properties(my_static_lib PROPERTIES
    POSITION_INDEPENDENT_CODE ON
)
```
- 설정하지 않으면 특히 arm64 ABI에서 링크 에러가 발생할 수 있다.

### add_library(\<name> IMPORTED)
이미 빌드된 외부 라이브러리를 CMake 타겟으로 등록한다.
```cmake
add_library(onnxruntime SHARED IMPORTED)
set_target_properties(onnxruntime PROPERTIES
    IMPORTED_LOCATION ${ONNXRUNTIME_LIB_DIR}/libonnxruntime.so
)
```
- 외부에서 빌드된 `.so`/`.a` 파일을 직접 사용할때 필요
- ffmpeg, onnxruntime 자체 Native SDK 등에 자주 사용한다.

### find_package(\<package_name> [version] [REQUIRED] [COMPONENTS])
종속 라이브러리 찾기

CMake 가 시스템 경로나 지정된 경로에서 이미 존재하는 라이브러리 또는 모듈을 찾아 로드한다.
> Gradle(implementation) 처럼 라이브러리를 인터넷에서 다운로드 & 설치해주는 명령어가 아님. 이미 컴퓨터나 프로젝트 내에 설치된(존재하는) 라이브러리의 위치를 찾아 연결해주는 역할을 한다.
{: .prompt-warning }

- **package_name** : 찾고자 하는 라이브러리 이름(대소문자 구분함)
- **REQUIRED** : 라이브러리를 찾지 못하면 경고에서 그치지 않고, **빌드 자체를 실패(에러)**로 처리한다. 필수 라이브러리일때 사용한다.
- **CONFIG** : CMake 내장 검색 방식("Find 모듈")을 건너뛰고, 라이브러리 제작자가 제공하거나 빌드 시스템이 생성한 "설정 파일(`*Config.cmake`)" 을 우선적으로 찾도록 강제한다.

Android Gradle 에서 prefab 을 지원하는 라이브러리(예 : Oboe) 를 implementation 하면, Gradle 이 다운로드한 AAR 내부에 CMake 를 위한 설정 파일이 자동 생성된다. 이를 CMake 에서 인식하기 위해 아래와 같이 사용된다.
```cmake
find_package(oboe REQUIRED CONFIG)
```

### find_library(\<variable_name> \<library_name>)
특정 라이브러리를 찾고, 그 경로를 변수에 저장한다
- **\<variable_name>** : 찾은 라이브러리의 경로가 저장될 변수 이름
- **\<library_name>** : 찾을 라이브러리의 실제 이름

### target_include_directories(\<target> [PUBLIC / PRIVATE / INTERFACE] \<dirs>)
컴파일러가 헤더파일을 찾을 위치 지정
- **\<target>** : 라이브러리 이름. add_library 로 지정한 이름
- **PRIVATE** : 해당 라이브러리 내부에서만 사용
- **PUBLIC** : 라이브러리 내부 + 이를 사용하는 대상에게도 전파
- **INTERFACE** : 사용하는 대상에게만 적용

> `include_directories() 는 전역 설정이므로 의존성 관리가 어려워진다.  
> NDK 프로젝트에서는 target_include_directories() 사용이 권장된다.
{: .prompt-tip }

### target_link_libraries(\<target> [PUBLIC / PRIVATE / INTERFACE] \<items>)
생성된 라이브러리 또는 실행파일이 의존하는 다른 라이브러리 연결
- **\<target>** : 라이브러리 이름. add_library 로 지정한 이름
- **\<items>** : 연결할 라이브러리 목록
  - **find_library**  로 찾은 변수
  - **add_library** 로 정의된 다른 라이브러리 이름
  - **find_package** 로 찾은 라이브러리 이름

### add_subdirectory(\<dir>)
하위 디렉터리의 CMakeLists.txt 를 현재 빌드에 포함시킨다.
```
add_subdirectory(native_utils)
add_subdirectory(audio_enginie)
```
- Native 코드가 커질수록 모듈 분리를 위해 필수적으로 사용된다.
- 각 디렉터리는 독립적인 CMake 타겟을 가질 수 있다.

## JNI 구성
JNI Bridge 는 Kotlin 코드와 Native(cpp) 코드가 서로 대응되는 구조로 동작한다.

Kotlin 쪽에서는 Native 함수를 선언하고, Native 쪽에서는 해당 선언을 구현한다.(개념적으로 Interface 와 구현체와 비슷하다.)

Kotlin 부분은 아래와 같은 형태이다.
```kotlin
class JniBridge {
    companion object {
        init {
            System.loadLibrary("test-jni-bridge")
        }
    }

    external fun swapString(origin: String): String
    ...
}
```
- `JniBridge` : 클래스명은 자유롭게 지정할 수 있다.
- `System.loadLibrary` : CMakeLists.txt 의 add_library 에서 지정한 공유 라이브러리를 로드한다. JVM 과 Native(.so) 를 연결하는 역할을 한다.
- `external fun ...` : Native 영역에 구현될 함수를 JVM 에 선언한다. Kotlin 코드에서 `JniBridge().swapString("1234")` 를 호출하면 JNI 를 통해 Native(.so) 에 구현된 함수가 실행된다

NDK 의 cpp 부분은 아래와 같은 형태이다.
```cpp
#include <jni.h>
#include <string>

extern "C" JNIEXPORT jstring JNICALL
Java_com_example_sample_JniBridge_swapString(
        JNIEnv* env,
        jobject thiz,
        jstring origin
) {
    ...
}
...
```
- 위 함수는 kotlin 에서 선언한 `external fun swapString` 과 연결된다.
- 함수 이름과 시그니처는 JNI 규칙에 의해 결정된다.
    - `Java_패키지명_Kotlin 쪽 JNI Bridge 명_함수명` 형태이다. 실제로는 패키지명과 클래스명의 '.' 이 '_' 로 대체된다. 또한 기존 패키지명의 _ 는 _1로 표현된다.
    - 예시 패키지명이 com.example.sample_jni 이고 JNI Bridge 클래스명이 TestJni, 함수명이 callNative 라면  
    `Java_com_example_sample_1jni_TestJni_callNative` 가 된다.
- `extern "C" JNIEXPORT jstring JNICALL`
  - **extern** : 외부에서 사용할 심볼임을 선언
  - **extern "C"** : C++ 이름 변경 금지(C++ 은 컴파일시 함수 이름을 바꾼다. JVM 에서 찾을 수 있도록 변경을 금지하는 역할이다)
  - **JNIEXPORT** : .so 를 외부에 공개한다. JVM 에서 호출할 수 있도록 한다
  - **JNICALL** : JVM 호출 규약에 맞춘다.
  - **jstring** : 함수 리턴타입을 지정한다. 예시 함수는 문자열을 반환한다.

## MVVM Pattern(Clean Architecture) 관점
MVVM 의 관점으로 보면

**JNI Bridge** : DataSource 에서 데이터의 원천에 접근하는 저수준 인터페이스이다. API 통신을 예로 들자면, Retrofit 객체와 같은 역할이다.

**.so** : Native Library 는 데이터의 원천이다. API 통신을 예로 들자면 서버와 DB 인 셈이다.

API 통신을 MVVM Patern 으로 구현한다면
```mermaid
flowchart LR
    A["데이터 요청(UseCase / Repository)"] --> B["DataSource(Impl)"]
    B --> C["Retrofit Obj"]
    C --> |API 요청| D["Server"]
    D --> E[(Database)]
    E --> D
    D --> |API 응답| C
    C --> B
    B --> A
```
의 흐름으로 외부의 데이터를 요청하고 가져오게 된다.

JNI/NDK 기반 프로젝트에서도 Clean Architecture 를 적용한다면 아래와 같은 흐름으로 동작한다.
```mermaid
flowchart LR
    A["데이터 요청(UseCase / Repository)"] --> B["DataSource(Impl)"]
    B --> C["JNI Bridge"]
    C --> |native 호출| D["Native Library(.so)"]
    D --> |native 결과| C
    C --> B
    B --> A
```

이들은 3 Layer 기준으로 봤을때, 모두 Data Layer 에 속하게 된다.

즉, JNI/NDK 역시 외부 데이터 소스 접근이라는 관점에서 API 통신과 동일한 아키텍처 패턴으로 다룰 수 있다.